
Why Cosmos?
---

Why a new language? What can it be used for? This tends to be a common question for any new language.

_As a scripting language_

As you can see, we aimed for a language that's very readable, simple and concise.

The syntax compares well to common scripting languages.

Cosmos is a good general-purpose _scripting language_. It fares well for scripts, prototyping or high-level applications.

Many languages nowadays are becoming overly complex and opinionated. Cosmos is an alternative to those; it strives to go back to what scripting languages were known for. 

_As a functional language_

It's a goal of us to ensure Cosmos can be used as a legitimate _functional language_. It's provided with constructs like closures and a focus on immutability.

_As a logic language_

Cosmos is a legitimate _logic language_. It's our view of what a modern day logic language would look like.

It's entirely possible to use it as a regular language, however, then switch to using logic features (such as non-determinism) later.

Cosmos is designed so that even if you use write code with an entirely procedural mindset, it will have a functional and logic meaning.

_An academic language?_

Declarative languages are often used academically.

Cosmos covers all main paradigms and even advanced concepts such as functors while benefitting from a more recognizable syntax.

It's not Prolog
--

As a _logic programming language_ based on Prolog, Cosmos can be easily compared to Prolog. It's not Prolog, of course!

Many features of ancient, classic Prolog (such as variables needing to be uppercase) did arguably not age well and are not common today.

Overall, we did not adopt those.

Philosophy
----

The philosophy of the Cosmos programming language can be summed in a few precepts, which the language was designed around,

- Exploratory
- Familiarity
- Minimalism
- Smooth

Of course, those precepts are weighted against each other.

_Exploratory
_Familiarity_

Cosmos is ultimately an experimental language. It's a logic language, after all.

If it was merely another imperative scripting language, there would be no reason to make it. Plenty of those already exist.

Then, it's more accurate to say that _we do not deviate from the norm if we don't have to_.

So as to be as user-friendly as possible, it uses a procedural syntax with all the common operators you'd expect from one--unless there's a reason not to.

This is also exploratory, since likewise plenty of languages with so-called functional syntax do exist. A declarative language with an imperative syntax is still less common than most realize.

This applies specially to naming- when naming a function, we try to pick the naming that's most commonly found for it.

_Minimalism_

"Make it simple, but not simpler."

The above quote quite describes a minimalist philosophy. Many languages are full of multiple syntaxes and operators- even if do we have some syntax sugar, we can hardly measure to our competition.

At the least, they don't follow the same philosophy as ours.

Basic function or relation syntax exists so that we don't need new operators for everything. 

This has the advantage of making our language readable and quick to learn!

_Smooth_

Adopting common syntax sugar is an example of smoothness. It makes our language smooth to program in, which is important, after all.

Weighting the Precepts
--

These precepts may of course sometimes clash. Cosmos may choose to explore a paradigm that's not all that common, which may clash against familiarity. We don't want to make our language so minimal that it is unusable-- thus we weight it against the smoothness factor.

It's not always so, though. You may note a lot of the time features simply fit and go well together. This is ideal.


